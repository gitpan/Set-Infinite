TODO - version 0.22

	make offset accept ICal times

	change recurring.pl because offset supports 'Date' hours

	make offset support days, etc.

	extra: offset option "middle"

	extra: "indexes" filter to help dealing with sparse lists:
	(,,10,,12,,14,,,)->indexes gives (2,4,6)

	extra: caching for the filters. Try "Memoize".

	internal: it may be good to have a pointer to the "root" object
	in the filters. Thay already have a "parent" pointer.

	think about: caching for union, etc  

	check: english: "infinite" x "infinity"

	check: if Set::Infinite->is_null works after quantize

	think about: "push-pop", "dup", "drop" mechanism

	think about: some "if-else" mechanism

	extra: wrappers (like: weekday('thursday') )
	some tough cases: yearweek(10) monthweek(2)

	extra: multiple offset (like: two days in month) 

	oo: provide a general filter mechanism (quantize, select, etc)

	tie: make "virtual" union, etc ? -- would be new filters

	check: cleanup "type" hack

	optimization: Set::Infinite : assume the list is sorted : union, intersect, etc

	oo-date: check for extensibility

	extra: check if it is working: min and max for quantize, select, offset

	extra: make work with -inf, inf : quantize, select, offset 

	extra: make compact set : quantize, select.
	offset is ok.
	will need some kind of internal index.

	extra: syntax for quantize: ...->quantize('years')

	correction: Date::sub -> propagate "mode"

	check: POD formatting 

	check: RFC2445 support completeness

	doc: "select" options: 
	  "quantize" output processors, for RFC2445 processing:
	FREQ=YEARLY
		->quantize( unit=>'years' )

		Interval(-inf .. inf) ->quantize( unit=>'years')
		- would be a runtime error because 
		Quantize->new needs a "base", and -inf does not work.
		- unless we don't instantiate ?

	INTERVAL=4
		...->quantize('years',1)->select(freq => 4)
		"Each four years, starting in the first year"
		...->quantize('years',1)->select(freq=>4,by=>[3])
		"Each four years, starting in the third year"
	BYMONTH=11;BYDAY=TU;BYMONTHDAY=2,3,4
		$tmp = $a->quantize('years',1)->offset( .. 'begin', 11 months ... );
		$thursdays = ...weeks .. offset ..;
		$days = ...->select( .. by=>[1,2,3] ...);
		$result = $thursdays->intersection($days);

	FREQ=MONTHLY;COUNT=3
		rewrite this: 
		  ...->freq('months',3)
	FREQ=MINUTELY;INTERVAL=15;COUNT=6
		rewrite this: 
		  ...->freq('minutes',15 * 6)->freq('minutes',1)->interval(0,15)->
		  Needs a lot of pre-processing to generate "freq('minutes',15 * 6)"!
	BYSETPOS=-2
		write about this
	WKST
		write about this	
	UNTIL=19970902T170000Z
		->intersect( -inf .. "19970902T170000Z" )

	extra: Keep a pointer to object in "quantize", such that, if the object is changed,
	"quantize" will re-initialize. 
	Make a "object_modified" flag in "quantize",
	that the object should point back to. Sort of a signal handler.

	extra: Make a 'strict' option for "quantize" and other filters, 
	that will intersect
	each unit back to the object, that is:
	Interval:                     [************************]
	Quantized:                [*********)[*********)[*********)
	Quantized->Stricted:          [*****)[*********)[******]

	old: Make a private mode for `type'

	old: Make a global mode for `open_*' 

	old: Create a `dirty' variable so it knows when to cleanup.

	old: Find out how to accelerate `type' mode.

	old: use `isa' to test parameter types

	oo: use __PACKAGE__ everywhere

	old: correct syntax problems due to accepting ( [ 1 .. 10 ] ) as input - see POD.

	old: fix Bigfloat tests

	old: Quantize_Date should care of daylight savings time

